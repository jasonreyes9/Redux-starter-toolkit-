---
id: migrating-to-rtk-query
title: Migrating to RTK Query
sidebar_label: Migrating to RTK Query
hide_title: true
---

# Migrating to RTK Query

The most common use case for side effects in Redux apps is fetching data. Redux apps typically use a tool like thunks, sagas, or observables to make an AJAX request, and [dispatch actions based on the results of the request](https://redux.js.org/tutorials/fundamentals/part-7-standard-patterns#async-request-status). Reducers then listen for those actions to manage loading state and cache the fetched data.

RTK Query is purpose-built to solve the use case of data fetching. While it can't replace all of the situations where you'd use thunks or other side effects approaches, using RTK Query should eliminate the need for most of that hand-written side effects logic.

RTK Query is expected to cover a lot of overlapping behaviour that users may have previously used `createAsyncThunk` for, including caching purposes, and request lifecycle management (e.g. `isUninitialized`, `isLoading`, `isError` states).

In order to migrate data-fetching features from existing Redux tools to RTK Query, the appropriate endpoints should be added to an RTK Query api, and the previous feature code deleted. This generally will not include much common code kept between the two, as the tools work differently and one will replace the other.

## Examples

The examples below demonstrate two methods of achieving a similar purpose: caching data from a request while also providing `isUninitialized`, `isLoading` & `isError` states associated with the request. The first method uses thunks & manually written reducers, while the second uses an api defined with RTK Query.

:::note
RTK Query provides a lot more than the features created with the thunk example shown below. The example is only intended to demonstrate how the common features below could be replaced with RTK Query.
:::

### Using thunks & manually written reducers

1. Create the appropriate thunk, add the appropriate reducers to your slice, and create selectors for the data and request statuses:

   ```ts title="src/services/pokemonSlice.ts"
   // file: src/services/types.ts noEmit
   export interface Pokemon {}

   // file: src/store.ts noEmit
   import { configureStore } from '@reduxjs/toolkit'
   import { pokemonSlice } from './services/pokemonSlice'

   export const store = configureStore({
     reducer: {
       pokemon: pokemonSlice.reducer,
     },
   })

   export type RootState = ReturnType<typeof store.getState>

   // file: src/services/pokemonSlice.ts
   import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
   import { Pokemon } from './types'
   import { RootState } from '../store'

   // highlight-start
   type RequestState = 'pending' | 'fulfilled' | 'rejected'
   // highlight-end

   // highlight-start
   const fetchPokemonByName = createAsyncThunk<Pokemon, string>(
     'pokemon/fetchByName',
     async (name, { rejectWithValue }) => {
       const response = await fetch(
         `https://pokeapi.co/api/v2/pokemon/${name}`
       ).then((res) => res.json())
       if (response.status < 200 || response.status >= 300) {
         return rejectWithValue(response)
       }
       return response
     }
   )
   // highlight-end

   export const pokemonSlice = createSlice({
     name: 'pokemon',
     initialState: {
       // highlight-start
       dataByName: {} as Record<string, Pokemon | undefined>,
       statusByName: {} as Record<string, RequestState | undefined>,
       // highlight-end
     },
     reducers: {},
     extraReducers: (builder) => {
       // highlight-start
       builder.addCase(fetchPokemonByName.pending, (state, action) => {
         state.statusByName[action.meta.arg] = 'pending'
       })
       builder.addCase(fetchPokemonByName.fulfilled, (state, action) => {
         state.statusByName[action.meta.arg] = 'fulfilled'
         state.dataByName[action.meta.arg] = action.payload
       })
       builder.addCase(fetchPokemonByName.rejected, (state, action) => {
         state.statusByName[action.meta.arg] = 'rejected'
       })
       // highlight-end
     },
   })

   // highlight-start
   export const selectStatusByName = (state: RootState, name: string) =>
     state.pokemon.statusByName[name]
   export const selectDataByName = (state: RootState, name: string) =>
     state.pokemon.dataByName[name]
   // highlight-end
   ```

1. If not done previously, add the reducer to your store setup:

   ```ts title="src/services/store.ts"
   // file: src/services/pokemonSlice.ts noEmit
   import { Reducer } from '@reduxjs/toolkit'
   declare const reducer: Reducer<{}>
   export const pokemonSlice = {
     reducer,
   }

   // file: src/store.ts
   import { configureStore } from '@reduxjs/toolkit'
   import { pokemonSlice } from './services/pokemonSlice'

   export const store = configureStore({
     reducer: {
       // highlight-start
       pokemon: pokemonSlice.reducer,
       // highlight-end
     },
   })

   export type RootState = ReturnType<typeof store.getState>
   ```

   Create a hook to manage accessing the appropriate data & request status:

   ```ts title="src/hooks.ts"
   // file: src/services/pokemonSlice.ts noEmit
   import { AsyncThunkAction } from '@reduxjs/toolkit'
   import { RootState } from '../store'
   interface Pokemon {}
   export declare const fetchPokemonByName: (
     arg: string
   ) => AsyncThunkAction<Pokemon, string, {}>

   export const selectStatusByName = (state: RootState, name: string) =>
     state.pokemon.statusByName[name]
   export const selectDataByName = (state: RootState, name: string) =>
     state.pokemon.dataByName[name]

   // file: src/store.ts noEmit
   interface Pokemon {}
   type RequestState = 'pending' | 'fulfilled' | 'rejected'

   const initialPokemonSlice = {
     dataByName: {} as Record<string, Pokemon | undefined>,
     statusByName: {} as Record<string, RequestState | undefined>,
   }
   export type RootState = {
     pokemon: typeof initialPokemonSlice
   }

   // file: src/hooks.ts
   import { useEffect } from 'react'
   import { useDispatch, useSelector } from 'react-redux'
   import { RootState } from './store'
   import {
     fetchPokemonByName,
     selectStatusByName,
     selectDataByName,
   } from './services/pokemonSlice'

   // highlight-start
   export function useGetPokemonByName(name: string) {
     const dispatch = useDispatch()
     const statusByName = useSelector((state: RootState) =>
       selectStatusByName(state, name)
     )
     const data = useSelector((state: RootState) =>
       selectStatusByName(state, name)
     )
     useEffect(() => {
       // upon mount or name change, if status is uninitialized, send a request
       // for the pokemon name
       if (statusByName === undefined) {
         dispatch(fetchPokemonByName(name))
       }
     }, [statusByName, dispatch, name])

     const isUninitialized = statusByName === undefined
     const isLoading = statusByName === 'pending'
     const isError = statusByName === 'rejected'
     const isSuccess = statusByName === 'fulfilled'

     return { data, isUninitialized, isLoading, isError, isSuccess }
   }
   // highlight-end
   ```

1. Use the manually created hook:

   ```tsx title="Usage in a react component"
   // highlight-start
   import * as React from 'react'
   import { useGetPokemonByName } from './hooks'
   // highlight-end

   export default function App() {
     // highlight-start
     const { data, isError, isLoading } = useGetPokemonByName('bulbasaur')
     // highlight-end

     return (
       <div className="App">
         {isError ? (
           <>Oh no, there was an error</>
         ) : isLoading ? (
           <>Loading...</>
         ) : data ? (
           <>
             <h3>{data.species.name}</h3>
             <img src={data.sprites.front_shiny} alt={data.species.name} />
           </>
         ) : null}
       </div>
     )
   }
   ```

### Using RTK Query

1. Add the appropriate endpoint to your api and export the automatically created hook:

   ```ts title="src/services/api.ts"
   // file: types.ts noEmit
   interface Pokemon {}

   // file: api.ts
   import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

   export const api = createApi({
     baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),
     endpoints: (build) => ({
       // highlight-start
       getPokemonByName: build.query<Pokemon, string>({
         query: (name) => `pokemon/${name}`,
       }),
       // highlight-end
     }),
   })

   // highlight-start
   export const { useGetPokemonByNameQuery } = api
   // highlight-end
   ```

1. If not done previously, add the reducer & middleware to your store setup, and optionally [set up listeners](../../api/rtk-query/setupListeners) for additional behaviour:

   ```ts title="src/store.ts"
   // file: src/services/api.ts noEmit
   import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'
   interface Pokemon {}

   export const api = createApi({
     baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),
     endpoints: (builder) => ({
       getPokemonByName: builder.query<Pokemon, string>({
         query: (name) => `pokemon/${name}`,
       }),
     }),
   })

   // file: src/store.ts
   import { configureStore } from '@reduxjs/toolkit'
   // highlight-start
   import { setupListeners } from '@reduxjs/toolkit/query'
   import { api } from './services/api'
   // highlight-end

   export const store = configureStore({
     reducer: {
       // highlight-start
       [api.reducerPath]: api.reducer,
       // highlight-end
     },
     // highlight-start
     middleware: (gDM) => gDM().concat(api.middleware),
     // highlight-end
   })

   // highlight-start
   setupListeners(store.dispatch)
   // highlight-end
   ```

1. Use the automatically created hook:

   ```tsx title="Usage in a react component"
   // highlight-start
   import * as React from 'react'
   import { useGetPokemonByNameQuery } from './services/api'
   // highlight-end

   export default function App() {
     // highlight-start
     // Using a query hook automatically fetches data and returns query values
     const { data, error, isLoading } = useGetPokemonByNameQuery('bulbasaur')
     // highlight-end

     return (
       <div className="App">
         {error ? (
           <>Oh no, there was an error</>
         ) : isLoading ? (
           <>Loading...</>
         ) : data ? (
           <>
             <h3>{data.species.name}</h3>
             <img src={data.sprites.front_shiny} alt={data.species.name} />
           </>
         ) : null}
       </div>
     )
   }
   ```
